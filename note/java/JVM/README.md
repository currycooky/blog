# JVM

## Java监控工具

* jcmd：打印Java进程所设计的基本类、线程和VM信息
* jconsole：打开图形化试图
* jhat：读取内存堆转储
* jmap：提供堆转储和其他JVM内存使用的信息
* jinfo：查看JVM系统属性
* jstack：转储Java进程的栈信息
* jstat：GC和类装载活动信息
* jvisualvm：监视JVM的GUI工具

## JIT编译器

### 编译型

像C++这样的语言被称为编译型语言。程序以编译后的二进制形式交付：先写程序，然后用编译器静态生成二进制文件。而且这个二进制文件是针对特定的CPU的，一些新版本的CPU会加入一些新指令，而这部分指令无法在老版本CPU中执行。

### 解释型

而像PHP这样的语言被称为解释型语言。只要机器上有合适的解释器，相同的代码就可以在任何CPU上运行。执行程序时，解释器会将相应的代码转换为二进制代码。

### 即时编译

Java试图走一条中间路线。Java应用会被编译，但不是编译成特定CPU所专用的二进制代码，而是Java字节码，在代码执行时，编译器会将其编译成平台特定的二进制代码。

JVM在执行代码时，并不会立即编译代码，因为如果代码只执行一次，编译完全是浪费精力，而且解释执行会比编译后再执行的速度快。

但如果代码是经常调用的方法，或者是运行很多次迭代的循环，JVM就会对这段代码进行编译，并且对这段代码进行大量优化，即**热点编译**。

## 垃圾回收

### 分代垃圾收集器

根据不同的情况，将堆划分为不同的不同的代（老年代和新生代，而新生代又细分为Eden空间和Survivor空间）。

对象首先在新生代（Eden空间）中分配，当新生代满了之后，垃圾收集器暂停所有应用线程，回收新生代空间。不再使用的对象会被回收，仍然使用的对象会被移动到其他地方，这种操作被称为**Minor GC**。

对象不断地被移动到老年代，最终老年代的空间也会填满，JVM需要找出老年代中不再使用的对象，对它们进行回收。

直接停掉所有的应用线程，找出不再使用的对象，对其进行回收，接着对堆空间进行整理，这个过程被称为**Full GC**，通常会导致应用程序线程长时间停顿。

而通过更加复杂的计算，在应用线程运行的同时就找出不再适用的对象，采用这种方式的收集器被称为**Concurrent垃圾收集器**（CMS和G1就是采用的这种方式）。它们将应用线程停顿的时间降到了最小，也被称为低停顿（Low-Pause）收集器。如果CPU足够强劲，使用这种收集器可以避免发生Full GC，从而让任务运行的更快。

### GC算法

1. Serial垃圾收集器
   
   Serial收集器使用单线程清理堆内容，无论是进行Minor GC还是Full GC，都会暂停所有的应用线程。进行Full GC时，会对老年代的空间进行压缩整理。
   
   通过`-XX:+UseSerialGC`标志启用，指定另一种垃圾收集器来停用。

2. Throughput垃圾收集器
   
   采用多线程回收新生代空间，Minor GC的速度会比Serial收集器快得多。Full GC也能使用多线程方式。JDK7u4之后的版本可以通过`-XX:+UseParallelOldGC`来开启。因为使用多线程，所以也常常被称为Parallel收集器。
   
   Minor GC和Full GC时会暂停所有的应用线程，同时在Full GC时对老年代空间进行压缩整理。
   
   它已经是默认的收集器，如有需要，可以通过`-XX:+UseParallelGC`、`-XX:+UseParallelOldGC`来手动开启。

3. CMS收集器

4. 

5. G1垃圾收集器

6. 