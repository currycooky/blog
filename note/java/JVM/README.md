# JVM

## Java监控工具

* jcmd：打印Java进程所设计的基本类、线程和VM信息
* jconsole：打开图形化试图
* jhat：读取内存堆转储
* jmap：提供堆转储和其他JVM内存使用的信息
* jinfo：查看JVM系统属性
* jstack：转储Java进程的栈信息
* jstat：GC和类装载活动信息
* jvisualvm：监视JVM的GUI工具

## JIT编译器

### 编译型

像C++这样的语言被称为编译型语言。程序以编译后的二进制形式交付：先写程序，然后用编译器静态生成二进制文件。而且这个二进制文件是针对特定的CPU的，一些新版本的CPU会加入一些新指令，而这部分指令无法在老版本CPU中执行。

### 解释型

而像PHP这样的语言被称为解释型语言。只要机器上有合适的解释器，相同的代码就可以在任何CPU上运行。执行程序时，解释器会将相应的代码转换为二进制代码。

### 即时编译

Java试图走一条中间路线。Java应用会被编译，但不是编译成特定CPU所专用的二进制代码，而是Java字节码，在代码执行时，编译器会将其编译成平台特定的二进制代码。

JVM在执行代码时，并不会立即编译代码，因为如果代码只执行一次，编译完全是浪费精力，而且解释执行会比编译后再执行的速度快。

但如果代码是经常调用的方法，或者是运行很多次迭代的循环，JVM就会对这段代码进行编译，并且对这段代码进行大量优化，即**热点编译**。

## 垃圾回收

### 分代垃圾收集器

根据不同的情况，将堆划分为不同的不同的代（老年代和新生代，而新生代又细分为Eden空间和Survivor空间）。

对象首先在新生代（Eden空间）中分配，当新生代满了之后，垃圾收集器暂停所有应用线程，回收新生代空间。不再使用的对象会被回收，仍然使用的对象会被移动到其他地方，这种操作被称为**Minor GC**。

对象不断地被移动到老年代，最终老年代的空间也会填满，JVM需要找出老年代中不再使用的对象，对它们进行回收。

直接停掉所有的应用线程，找出不再使用的对象，对其进行回收，接着对堆空间进行整理，这个过程被称为**Full GC**，通常会导致应用程序线程长时间停顿。

而通过更加复杂的计算，在应用线程运行的同时就找出不再适用的对象，采用这种方式的收集器被称为**Concurrent垃圾收集器**（CMS和G1就是采用的这种方式）。它们将应用线程停顿的时间降到了最小，也被称为低停顿（Low-Pause）收集器。如果CPU足够强劲，使用这种收集器可以避免发生Full GC，从而让任务运行的更快。

### GC算法

1. Serial垃圾收集器
   
   Serial收集器使用单线程清理堆内容，无论是进行Minor GC还是Full GC，都会暂停所有的应用线程。进行Full GC时，会对老年代的空间进行压缩整理。
   
   通过`-XX:+UseSerialGC`标志启用，指定另一种垃圾收集器来停用。

2. Throughput垃圾收集器
   
   采用多线程回收新生代空间，Minor GC的速度会比Serial收集器快得多。Full GC也能使用多线程方式。JDK7u4之后的版本可以通过`-XX:+UseParallelOldGC`来开启。因为使用多线程，所以也常常被称为Parallel收集器。
   
   Minor GC和Full GC时会暂停所有的应用线程，同时在Full GC时对老年代空间进行压缩整理。
   
   它已经是默认的收集器，如有需要，可以通过`-XX:+UseParallelGC`、`-XX:+UseParallelOldGC`来手动开启。

3. CMS收集器
   
   使用新的算法来收集新生代对象（`-XX:+UseParNewGC`）。
   
   Full GC不再暂停应用程序，而是使用若干个后台线程定期对老年代空间进行扫描，及时回收不再使用的对象。因为不再进行整理操作，所以堆会逐渐变得碎片化。如果CMS的后台线程无法获得完成它们任务搜需要的CPU资源，或者堆变得过度碎片化以至于无法找到连续空间分配对象，CMS就蜕化到Serial收集器行为，之后又恢复到并发运行，再次启动后台线程，直到下一次变得过度碎片化。
   
   通过`-XX:+UseConcMarkSweepGC`、`-XX:+UseParNewGC`可以启用CMS垃圾收集器。

4. G1垃圾收集器
   
   设计初衷是为了尽量缩短处理超大堆（大于4GB）时产生的停顿。
   
   G1收集算法将堆划分为若干个区域（依旧属于分代收集器），老年代的垃圾手机工作由后台线程完成，大多数工作不需要暂停应用线程。由于老年代被划分到不同的区域，G1收集器通过将对象从一个区域复制到另一个区域，完成对象的清理工作，这意味着在正常的处理过程中，G1收集器完成了（一部分）堆的压缩整理。所以使用G1收集器不大容易发生堆大量碎片化。
   
   通过`-XX:+UseG1GC`启动G1垃圾收集器。

**触发及禁用显示的垃圾收集**

通过`System.gc()`可以主动触发垃圾回收（Full GC），但这不是一个好的操作，尽量要避免（性能监控或基准测试除外）。可以通过`-XX:+DisableExplicitGC`显示地禁止这种类型的GC。

RMI作为分布式垃圾收集器的一部分，每隔一个小时它会调用`System.gc()`一次，可以通过设置`-Dsun.rmi.dgc.server.gcInterval=N`和`-Dsun.rmi.dgc.client.gcInterval=N`进行修改。N值的单位以毫秒记。