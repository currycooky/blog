:icons: font

== Chapter 1
1. When and how to create objects?
2. When and how to avoid creating objects?
3. How to ensure objects are destroyed in a timely manner?
4. How to manage any cleanup actions that must precede their destruction?

=== Item 1: Use static factory methods
Like this:
[source, java]
----
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
----
The static factory method is not the same sa the _Factory Design Patterns_.

.*Advantages*
1. A static facotry method with a well-chosen name is easier to use and read.
2. Not required to create a new object each time they're invoked. Static factory method can cache object, and to avoid creating unnecessary duplicate objects, each time invoked always return same object.
3. Can return an object of any subtype of their return type, and return objects whithout making their classes public, like _SingletonSetfootnote:[java.util.Collections#singleton; java.util.Collections.SingletonSet]_.
4. Returned object can vary from call to call as a function of the input parameters, like _EnumSetfootnote:[java.util.EnumSet#noneOf]_.
5. Class of the returned object need not exist when the class containing the method is written, like _JDBC Driver_.

.*Disadvantages*
1. Is that classes without public or protected constructors cannot be subclassed. But this encourages programmers to use composition instead of inheritance.
2. Hard for programmers to find(I don't think this is a disadvantage.).

TIP: So, often static facoties are preferable, so we should first consider static factories.

=== Item 2: Consider using Builder instead of constructor with many parameters
.*Create Person Class*
[source, java]
----
public class Person {
    private final String id;
    private final String name;
    private final String sex;
    private final int age;

    public static class Builder {
        private final String id;
        private String name;
        private String sex;
        private int age;

        public Builder(String id) {
            this.id = id;
        }

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder man() {
            this.sex = "Man";
            return this;
        }

        public Builder woman() {
            this.sex = "Woman";
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Person build() {
            return new Person(this);
        }
    }

    private Person(Builder builder) {
        this.name = builder.name;
        this.id = builder.id;
        this.sex = builder.sex;
        this.age = builder.age;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getSex() {
        return sex;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", Person.class.getSimpleName() + "[", "]")
                .add("id='" + id + "'")
                .add("name='" + name + "'")
                .add("sex='" + sex + "'")
                .add("age=" + age)
                .toString();
    }
}
----

.*New Person Object*
[source, java]
----
Person person = new Person.Builder("423123412412313")
    .name("Zhang San")
    .age(20)
    .man()
    .build();
System.out.println(person.toString());
----

In real work, I like to use _Builder_ pattern very much. The pattern makes creating objects very elegant and easier to read. I heartily recommend this pattern to you.

TIP: In real work, we can use Lombokfootnote:[https://projectlombok.org/] to simplify code, just need to import Lombok, and use @Builder annotation, lombok can generate Builder class by auto.

=== Item 3: Implementing Singleton with a private constructor or an Enum type
.*private constructor*
[source, java]
----
public class Person {
    private static final Person INSTANCE = new Person();

    private Person() {}

    public static Person getInstatnce() {
        return INSTANCE;
    }

    public void eating() {
        System.out.println("I'm eating.");
    }
}
----

.*Enum type*
[source, java]
----
public enum Person {
    INSTANCE;

    public void eating() {
        System.out.println("I'm eating.");
    }
}
----
TIP: Recommend using Enum type.

=== Item 4: Enforce noninstantiablity with a private constructor
[source, java]
----
public class UtilityClass {
    private UtilityClass() {
        throw new SomeError();
    }

    public static boolean negation(boolean flag) {
        return !flag;
    }
}
----
We also can add `final` flag to this class make it cannot be extend.
[source, java]
----
public final class UtilityClass {
    private UtilityClass() {
        throw new SomeError();
    }

    public static boolean negation(boolean flag) {
        return !flag;
    }
}
----

=== Item 5: Prefer dependency injection to hardwiring resources
.*Noncompliant Code Example*
[source, java]
----
public class A {
    public void exe() {
        B b = new B();
        b.exe();
    }
}
----

.*Compliant Code Example*
[source, java]
----
public class A {
    private final B b;

    public A(B b) {
        this.b = b;
    }

    public void exe() {
        b.exe();
    }
}
----

=== Item 6: Avoid creating unnecessary objects
Example:
[source, java]
----
public boolean isRoman(String s) {
    return s.matches("ROMAN");
}
----
We can see `matches()` source code, each time invoke, `matches()` will create a Pattern instance, and uses it only once and then destroy it.

We could totally create an immutable Pattern instance, cache it, and can give it an appropriate name.
[source, java]
----
private static final Pattern ROMAN = Pattern.compile("ROMAN");

public boolean isRoman(String s) {
    return ROMAN.matcher(s).matches();
}
----
And avoid to create unnecessary objects is autoboxing.

=== Item 7: Eliminate obsolete object references
Memory leaks in garbage-collected languages are insidious. If an object reference is unintentionally retained, not only is that object excluded from garbage coolection, but so too are any objects referenced by that object, and so on.

Generally speaking, whenever a class manages its own memory, the programer should be alter for memory leaks. Whenever an element is freed, any object references contained in the element should be nulled out.

=== Item 8: Avoid finalizers and cleaners
IMPORTANT: NEVER! USE! THE! FINALIZER! METHOD!

=== Item 9: Prefer try-with-resources to try-finally
.*Bad Smell*
[source, java]
----
InputStream inputStream = null;
try {
    inputStream = new FileInputStream("NotDoThis.txt");
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (inputStream != null) {
        try {
            inputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
----
.*You Should Do Like That*
[source, java]
----
try (InputStream inputStream = new FileInputStream("Good.txt")) {
    // ...
} catch (IOException e) {
    e.printStackTrace();
}
----
NOTE: The Java version must be jdk1.7 or higher.