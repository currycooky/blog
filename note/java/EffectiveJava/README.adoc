= Effective Java
:toc: left
:icons: font
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
Curry Cooky <currycooky@qq.com>
1.0, 2022-09-01

== Chapter 1: Creating and Destroying Objects
1. When and how to create objects?
2. When and how to avoid creating objects?
3. How to ensure objects are destroyed in a timely manner?
4. How to manage any cleanup actions that must precede their destruction?

=== Item 1: Use static factory methods
Like this:
[source, java]
----
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
----
The static factory method is not the same sa the _Factory Design Patterns_.

.*Advantages*
1. A static facotry method with a well-chosen name is easier to use and read.
2. Not required to create a new object each time they're invoked. Static factory method can cache object, and to avoid creating unnecessary duplicate objects, each time invoked always return same object.
3. Can return an object of any subtype of their return type, and return objects whithout making their classes public, like _SingletonSetfootnote:[java.util.Collections#singleton; java.util.Collections.SingletonSet]_.
4. Returned object can vary from call to call as a function of the input parameters, like _EnumSetfootnote:[java.util.EnumSet#noneOf]_.
5. Class of the returned object need not exist when the class containing the method is written, like _JDBC Driver_.

.*Disadvantages*
1. Is that classes without public or protected constructors cannot be subclassed. But this encourages programmers to use composition instead of inheritance.
2. Hard for programmers to find(I don't think this is a disadvantage.).

TIP: So, often static facoties are preferable, so we should first consider static factories.

=== Item 2: Consider using Builder instead of constructor with many parameters
.*Create Person Class*
[source, java]
----
public class Person {
    private final String id;
    private final String name;
    private final String sex;
    private final int age;

    public static class Builder {
        private final String id;
        private String name;
        private String sex;
        private int age;

        public Builder(String id) {
            this.id = id;
        }

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder man() {
            this.sex = "Man";
            return this;
        }

        public Builder woman() {
            this.sex = "Woman";
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Person build() {
            return new Person(this);
        }
    }

    private Person(Builder builder) {
        this.name = builder.name;
        this.id = builder.id;
        this.sex = builder.sex;
        this.age = builder.age;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getSex() {
        return sex;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", Person.class.getSimpleName() + "[", "]")
                .add("id='" + id + "'")
                .add("name='" + name + "'")
                .add("sex='" + sex + "'")
                .add("age=" + age)
                .toString();
    }
}
----

.*New Person Object*
[source, java]
----
Person person = new Person.Builder("423123412412313")
    .name("Zhang San")
    .age(20)
    .man()
    .build();
System.out.println(person.toString());
----

In real work, I like to use _Builder_ pattern very much. The pattern makes creating objects very elegant and easier to read. I heartily recommend this pattern to you.

TIP: In real work, we can use Lombokfootnote:[https://projectlombok.org/] to simplify code, just need to import Lombok, and use @Builder annotation, lombok can generate Builder class by auto.

=== Item 3: Implementing Singleton with a private constructor or an Enum type
.*private constructor*
[source, java]
----
public class Person {
    private static final Person INSTANCE = new Person();

    private Person() {}

    public static Person getInstatnce() {
        return INSTANCE;
    }

    public void eating() {
        System.out.println("I'm eating.");
    }
}
----

.*Enum type*
[source, java]
----
public enum Person {
    INSTANCE;

    public void eating() {
        System.out.println("I'm eating.");
    }
}
----
TIP: Recommend using Enum type.

=== Item 4: Enforce noninstantiablity with a private constructor
[source, java]
----
public class UtilityClass {
    private UtilityClass() {
        throw new SomeError();
    }

    public static boolean negation(boolean flag) {
        return !flag;
    }
}
----
We also can add `final` flag to this class make it cannot be extend.
[source, java]
----
public final class UtilityClass {
    private UtilityClass() {
        throw new SomeError();
    }

    public static boolean negation(boolean flag) {
        return !flag;
    }
}
----

=== Item 5: Prefer dependency injection to hardwiring resources
.*Noncompliant Code Example*
[source, java]
----
public class A {
    public void exe() {
        B b = new B();
        b.exe();
    }
}
----

.*Compliant Code Example*
[source, java]
----
public class A {
    private final B b;

    public A(B b) {
        this.b = b;
    }

    public void exe() {
        b.exe();
    }
}
----

=== Item 6: Avoid creating unnecessary objects
Example:
[source, java]
----
public boolean isRoman(String s) {
    return s.matches("ROMAN");
}
----
We can see `matches()` source code, each time invoke, `matches()` will create a Pattern instance, and uses it only once and then destroy it.

We could totally create an immutable Pattern instance, cache it, and can give it an appropriate name.
[source, java]
----
private static final Pattern ROMAN = Pattern.compile("ROMAN");

public boolean isRoman(String s) {
    return ROMAN.matcher(s).matches();
}
----
And avoid to create unnecessary objects is autoboxing.

=== Item 7: Eliminate obsolete object references
Memory leaks in garbage-collected languages are insidious. If an object reference is unintentionally retained, not only is that object excluded from garbage coolection, but so too are any objects referenced by that object, and so on.

Generally speaking, whenever a class manages its own memory, the programer should be alter for memory leaks. Whenever an element is freed, any object references contained in the element should be nulled out.

=== Item 8: Avoid finalizers and cleaners
IMPORTANT: NEVER! USE! THE! FINALIZER! METHOD!

=== Item 9: Prefer try-with-resources to try-finally
.*Bad Smell*
[source, java]
----
InputStream inputStream = null;
try {
    inputStream = new FileInputStream("NotDoThis.txt");
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (inputStream != null) {
        try {
            inputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
----
.*You Should Do Like That*
[source, java]
----
try (InputStream inputStream = new FileInputStream("Good.txt")) {
    // ...
} catch (IOException e) {
    e.printStackTrace();
}
----
NOTE: The Java version must be jdk1.7 or higher.

== Chapter 2: Methods Common to All Objects
When and how to override the nonfinal Object methods?

=== Item 10: Overriding equals general contract
.Not need to override equals method:
. Each instance of the class is inherently unique.
. There is no need for the class to provide a "logical equality" test.
. A supercalss has already overridden equals, and the superclass behavior is appropriate for this class.
. The class is private or package-private, and you are certain that its equlas method will never be invoked.

.General contract
. Reflexive: x != null, x.equals(x) must return true.
. Symmetric: x,y != null, x.equals(y) == y.equals(x).
. Transitive: x,y,z != null, x.equals(y) == y.equals(z) == z.equals(x)
. Consistent: x,y != null and x,y not modified, multiple invocation of x.equals(y) must consistently.
. x != null, x.equals(null) must return false.

[NOTE]
====
. Always override hashCode when you override equals.
. Don't try to be too clever.
. Don't substitude another type for Object in the equals declaration.

    public boolean equals(MyClass o) {
        // Don't do it like this!
    }
====

=== Item 11: Always override hashCode when you override equals
[source, java]
----
@Override
public int hashCode() {
    return Objects.hash(value1, value2, value3, ...);
}
----

=== Item 12: Always override toString

=== Item 13: Override clone judiciously

=== Item 14: Consider implementing Comparable

== Chapter 3: Classes and Interfaces
Help you make the best use of these powerful elements so that your classes and interfaces are usable, robust and flexible.

=== Item 15: Minimize the accessibility of classes and members
Make each class or member as inaccessible as possible.

If a package-private top-level class or interface is used by only one class, consider making the top-level class a private static nested class of sole class that use it.

If a method override a superclass method, it cannot have a more restrictive access level in the subclass than in the superclass.

Instance fields of public classes should rarely be public. Classes with public mutable fields are not generally thread-safe. The same advice applies to static fields, except you can expose constants via public static final fields.

Nonzero-legnth array is always mutable, so it is wrong for a class to have a public static final array fields, or an accessor that returns such a field.

=== Item 16: In public classes, use accessor methods, not public fields
If a class is accessible outside its package, provide accessor methods to preserve the flexibility to change the class's internal representation.

In summary, public classes should never expose mutable fields.

=== Item 17: Minimize mutability
An imutable class is simply a class whose instances cannot be modified. All of the information contained in each instance is fixed for the lifetime of the object, so no changes can ever be observed.

To make a class immutable, follow these five rules:
. Don't provide methods that modify the object's state.
. Ensure that the class can't be extended.
. Make all fields final.
. Make all fields private.
. Ensure exclusive access to any mutable components.
[source, java]
----
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double re() {
        return re;
    }

    public double im() {
        return im;
    }

    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }

    public Complex times(Complex c) {
        return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
    }

    public Complex dividedBy(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp);
    }
}
----
Immutable objects are simple. An immutable object can be in exactly one state, the state in which it was created.

Immutable objects are inherently thread-safe; they require no synchronization.

The major disadvantage of immutable classes is that they require a separate object for each distinct value.

Resist the urge to write a setter for every getter. Classes should be immutable unless there's a very good reason to make them mutable.

There are some classes for which immutability is impractical. If a class cannot be made immutable, limit its mutability as much as possible. Make every field final unless there is a compelling reason to make it nonfinal.

Construtors should create fully initialized objects with all of their invariants established. Don't provide a public initialization method separate from the constructor or static factory unless there is a compelling reason to do so.

=== Item 18: Favor composition over inheritance
Inheritance violates encapsulation. It is appropriate only when a genuine subtype relationship exists between the subclass and the superclass. Even then, inheritance may lead to fragility if the subclass is in a different package from the superclass and the superclass is not designed for inheritance.

=== Item 19: Design and document for inheritance or else prohibit it
Test a class desiged for inheritance is to write subclasses. If you omit a crucial protected member, trying to write a subclass will make the omission painfully obvious.

If serveral subclasses are written and none uses a protected member, you should probably make it private.

Constructors must not invoke overridable methods.

The `Cloneable` and `Serializable` interfaces present special difficulties when designing for inheritance. Neither `clone` nor `readObject` may invoke an overridable method, directly or indirectly.

If you decide to implement `Serializable` in a class designed for inheritance and the class has a `readResolve` or `writeReplace` method, you must make them protected rather than private.

Designing a class for inheritance requires great effort and places substantial limitations on the class.

=== Item 20: Prefer interfaces to abstract classes
Existing classes cannot, in general, be retrofitted to extend a new abstract class. If you want to have two classes extend the same abstract class, you have to place it high up in the type hierarchy where it is an ancestor of both classes. Unfortunately, this can cause great collateral damage to the type hierarchy, forcing all descendants of the new abstract class to subclass it, whether or not it is appropriate.

=== Item 21: Design interfaces for posterity
Utmost importace to design interfaces with great care.

Test each new interface before you release it.

=== Item 22: Use interfaces only to define types
Do not use constant interface! The constant interface pattern is a poor use of interfaces. That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementtation detail to leak into the class's exported API.
[source, java]
----
public interface PhysicalConstatns {
    static final double NUMBER = 2.0D;
}
----

=== Item 23: Prefer class hierarchies to tagged classes
Tagged classes have numerous shortcomings. They are cluttered with bolierplate, including enum declasrations, tag fields, and switch statements. Readability and flexibility is further harmed because multiple implementations are jumbled together in a single class, and memory footprint is increased. Tagged classes are verbose, error-prone, and inefficient.
[source, java]
----
public abstract class Figure {
    abstract double area();
}

public class Circle extends Figure {
    final double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double area() {
        return Math.PI * (radius * radius);
    }
}

public class Rectangle extends Figure {
    final double length;
    final double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    double area() {
        return length * width;
    }
}
----

=== Item 24: Favor static member classes over nonstatic
If you declare a member class that does not require access to an eclosing instance, always put the static modifier in its declaration, making it s static rather than a nonstatic member class.

=== Item 25: Limit source files to a single top-level class
Never put multiple top-level classes or interfaces in a single source file.
[source, java]
----
public class Circle extends Figure {
    final double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double area() {
        return Math.PI * (radius * radius);
    }
}

public class Rectangle extends Figure {
    final double length;
    final double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    double area() {
        return length * width;
    }
}
----
[source, java]
----
public abstract class Figure {
    abstract double area();

    public class Circle extends Figure {
        final double radius;

        public Circle(double radius) {
            this.radius = radius;
        }

        @Override
        double area() {
            return Math.PI * (radius * radius);
        }
    }

    public class Rectangle extends Figure {
        final double length;
        final double width;

        public Rectangle(double length, double width) {
            this.length = length;
            this.width = width;
        }

        @Override
        double area() {
            return length * width;
        }
    }

}
----

== Chapter 4: Generics
How to maximize the benefits and minimize the complications.

=== Item 26: Don't use raw types
[source, java]
----
// Don't do this!
private final Collection stamps = ...;
----
If you use raw types, you lose all safety and expressiveness benefits of Generics, but not if you use a parameterized type such as List<Objecjt>.

=== Item 27: Eliminate unchecked warnings
[source, java]
----
// Don't do this!
Set<String> strs = new HashSet();

// You can do like this.
Set<String> strs = new HashSet<>();
----
Eliminate every unchecked warning that you can. If you eliminate all warnings, you are assured that you code is typesafe, which is a very good thing.

If you cann't eliminate a warning, but you can prove that the code that provoked the warning is typesafe, then (and only then) suppress the warning with an `@SuppressWarnings("unchecked")` annotation. Always use the `@SuppressWarnings` on the smallest scope possible, never use it on an entire class.

Also can declare a local variable:
[source, java]
----
@SuppressWarnings("unchecked") T[] result = Arryas.copyOf(elements, size, a.getClass());
----

Every time you use a `@SuppressWanings("unchecked")` annotation, add a comment saying why it is safe to do so.

=== Item 28: Prefer lists to arrays
[source, java]
----
Object[] objs = new Long[1];
objs[0] = "Error"; // Throws ArrayStoreException
----

[source, java]
----
List<Object> objs = new ArrayList<Long>(); // Incompatible types, won't compile!
----

=== Item 29: Favor generic types
Generic types are safer and easier to use than types that require casts in client code.
[source, java]
----
public class Stack<E> {
    private E[] elemetns;

    public Stack() {
        elements = (E[]) new Object[16];
    }
}
----

=== Item 30: Favor generic methods
[source, java]
----
// Uses raw types - unacceptable!
public static Set union(Set s1, Set s2) {
    Set res = new HashSet(s1);
    res.addAll(s2);
    return res;
}
----
[source, java]
----
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    Set<E> res = new HashSet<>(s1);
    res.addAll(s2);
    return res;
}
----

=== Item 31: Use bounded wildcards to increate API flexibility
[source, java]
----
public void pushAll(Iterable<? extends E> src) {
    for (E e : src) {
        push(e);
    }
}
----
For maximum flexibility, use wildcard types on input parameters that represent producers or consumers. If an input parameter is both a producer and a consumer, then wildcard types will do you no good: you need an exact  type match, which is what you get without any wildcards.

[.text-center]
*PECS stands for producer-extends, consumer-super*

Do not use bounded wildcard types as return types. If the user of a  class has to think about wildcard types, there is probably something wrong with its API.

=== Item 32: Combine generics and varargs judiciously
Recall that a generic array is created when the method is invoked, to hold the varargs parameters. If the method doesn't store anything into the array (which would overwrite the parameters) and doesn't allow a reference to the array to escape (which would enable untrusted code to access the array), then it's safe.

In summary, varargs and generics do not interact well because the varargs facility is a leaky abstraction built atop arrays, and arrays have different type rules from generics. Though generic varargs parameters are not typesafe, they are legal. If you choose to write a method with a generic (or parameterized) varargs parameter, first ensure that the method is typesafe, and then annotate it with `@SafeVarargs` so it is not unpleasant to use.

=== Item 33: Consider typesafe heterogeneous containers
[source, java]
----
public class Favorites {
    private Map<Class<?>, Object> favorites = new HashMap<>();

    public <T> void putFavorite(Class<T> type, T instance) {
        favorites.put(Objects.requireNonNull(type), type.cast(instance));
    }

    public <T> T getFavorite(Class<T> type) {
        return type.cast(favorites.get(type));
    }
}
----
The normal use of generics, exemplified by the collections APIS, restricts you to a fixed number of type parameters per container. You can get around this restriction by placing the type parameter on the key rather than the container.

== Chapter 6: Enums and Annotations

=== Item 34: Use enums instead of int constants
[source, java]
----
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;
public static final int ORANGE_NAVEL = 0;
----
This technique, known as the `_int enum pattern_`, has many shortcomings. It provides nothing in the way of type safety and little in the way of expressive power. The compiler won't complain if you pass an apple to a method that expects an orange, compare apples to orange with the `==` operator, or worse.

If you print such a constant or display it from a debugger, all you see is a number, which isn't very helpful.

Enums provide compile-time type safety. Attempts to pass values of the wrong type will result in compile-time errors, as will attempts to assign an expression of one enum type to a variable of another, or to use the `==` operator to compare values of different enum types.

Enum types with identically named constants coexist peachfully. You can add or reorder constants in an enum type without recompliling its clients. Finally, you can translate enums into printable strings by calling their `toString` method.

Enum types let you add arbitrary methods and fields and implement arbitrary interfaces.
[source, java]
----
public enum Operation {
    PLUS {
        public double apply(double x, double y) {
            return x + y;
        }
    },

    MINUS {
        public double apply(double x, double y) {
            return x - y;
        }
    }
}
----

So when should you use enums? Use enums any time you need a set of constants whose members are known at compile time.

=== Item 35: Use instance fields instead of ordinals
All enums have an `ordinal` method, which returns the numberical position of each enum constant in its type. But you should never use it.
[source, java]
----
public enum NumberEnum {
    ONE, TWO, THREE;

    public int num() {
        return ordinal();
    }
}
----
If the constants are reordered, the `num` method will break.

Never derive a value associated with an enum from its ordinal; store it in an instance field instead.
[source, java]
----
public enum NumberEnum {
    ONE(1), TWO(2), THREE(3);

    private final int num;

    NumberEnum(int num) {
        this.num = num;
    }

    public int num() {
        return num;
    }
}
----

=== Item 36: Use EnumSet instead of bit fields
[source, java]
----
public class Text {
    public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }
         
    // Any Set could be passed in, but EnumSet is clearly best
    public void applyStyles(Set<Style> styles) {
        // ...
    }
}

text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));
----

=== Item 37: Use EnumMap instead of ordinal indexing

=== Item 38: Emulate extensible enums with interfaces