= Effective Java
:toc: left
:icons: font
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
Curry Cooky <currycooky@qq.com>
1.0, 2022-09-01

== Chapter 1: Creating and Destroying Objects
1. When and how to create objects?
2. When and how to avoid creating objects?
3. How to ensure objects are destroyed in a timely manner?
4. How to manage any cleanup actions that must precede their destruction?

=== Item 1: Use static factory methods
Like this:
[source, java]
----
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
----
The static factory method is not the same sa the _Factory Design Patterns_.

.*Advantages*
1. A static facotry method with a well-chosen name is easier to use and read.
2. Not required to create a new object each time they're invoked. Static factory method can cache object, and to avoid creating unnecessary duplicate objects, each time invoked always return same object.
3. Can return an object of any subtype of their return type, and return objects whithout making their classes public, like _SingletonSetfootnote:[java.util.Collections#singleton; java.util.Collections.SingletonSet]_.
4. Returned object can vary from call to call as a function of the input parameters, like _EnumSetfootnote:[java.util.EnumSet#noneOf]_.
5. Class of the returned object need not exist when the class containing the method is written, like _JDBC Driver_.

.*Disadvantages*
1. Is that classes without public or protected constructors cannot be subclassed. But this encourages programmers to use composition instead of inheritance.
2. Hard for programmers to find(I don't think this is a disadvantage.).

TIP: So, often static facoties are preferable, so we should first consider static factories.

=== Item 2: Consider using Builder instead of constructor with many parameters
.*Create Person Class*
[source, java]
----
public class Person {
    private final String id;
    private final String name;
    private final String sex;
    private final int age;

    public static class Builder {
        private final String id;
        private String name;
        private String sex;
        private int age;

        public Builder(String id) {
            this.id = id;
        }

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder man() {
            this.sex = "Man";
            return this;
        }

        public Builder woman() {
            this.sex = "Woman";
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Person build() {
            return new Person(this);
        }
    }

    private Person(Builder builder) {
        this.name = builder.name;
        this.id = builder.id;
        this.sex = builder.sex;
        this.age = builder.age;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getSex() {
        return sex;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", Person.class.getSimpleName() + "[", "]")
                .add("id='" + id + "'")
                .add("name='" + name + "'")
                .add("sex='" + sex + "'")
                .add("age=" + age)
                .toString();
    }
}
----

.*New Person Object*
[source, java]
----
Person person = new Person.Builder("423123412412313")
    .name("Zhang San")
    .age(20)
    .man()
    .build();
System.out.println(person.toString());
----

In real work, I like to use _Builder_ pattern very much. The pattern makes creating objects very elegant and easier to read. I heartily recommend this pattern to you.

TIP: In real work, we can use Lombokfootnote:[https://projectlombok.org/] to simplify code, just need to import Lombok, and use @Builder annotation, lombok can generate Builder class by auto.

=== Item 3: Implementing Singleton with a private constructor or an Enum type
.*private constructor*
[source, java]
----
public class Person {
    private static final Person INSTANCE = new Person();

    private Person() {}

    public static Person getInstatnce() {
        return INSTANCE;
    }

    public void eating() {
        System.out.println("I'm eating.");
    }
}
----

.*Enum type*
[source, java]
----
public enum Person {
    INSTANCE;

    public void eating() {
        System.out.println("I'm eating.");
    }
}
----
TIP: Recommend using Enum type.

=== Item 4: Enforce noninstantiablity with a private constructor
[source, java]
----
public class UtilityClass {
    private UtilityClass() {
        throw new SomeError();
    }

    public static boolean negation(boolean flag) {
        return !flag;
    }
}
----
We also can add `final` flag to this class make it cannot be extend.
[source, java]
----
public final class UtilityClass {
    private UtilityClass() {
        throw new SomeError();
    }

    public static boolean negation(boolean flag) {
        return !flag;
    }
}
----

=== Item 5: Prefer dependency injection to hardwiring resources
.*Noncompliant Code Example*
[source, java]
----
public class A {
    public void exe() {
        B b = new B();
        b.exe();
    }
}
----

.*Compliant Code Example*
[source, java]
----
public class A {
    private final B b;

    public A(B b) {
        this.b = b;
    }

    public void exe() {
        b.exe();
    }
}
----

=== Item 6: Avoid creating unnecessary objects
Example:
[source, java]
----
public boolean isRoman(String s) {
    return s.matches("ROMAN");
}
----
We can see `matches()` source code, each time invoke, `matches()` will create a Pattern instance, and uses it only once and then destroy it.

We could totally create an immutable Pattern instance, cache it, and can give it an appropriate name.
[source, java]
----
private static final Pattern ROMAN = Pattern.compile("ROMAN");

public boolean isRoman(String s) {
    return ROMAN.matcher(s).matches();
}
----
And avoid to create unnecessary objects is autoboxing.

=== Item 7: Eliminate obsolete object references
Memory leaks in garbage-collected languages are insidious. If an object reference is unintentionally retained, not only is that object excluded from garbage coolection, but so too are any objects referenced by that object, and so on.

Generally speaking, whenever a class manages its own memory, the programer should be alter for memory leaks. Whenever an element is freed, any object references contained in the element should be nulled out.

=== Item 8: Avoid finalizers and cleaners
IMPORTANT: NEVER! USE! THE! FINALIZER! METHOD!

=== Item 9: Prefer try-with-resources to try-finally
.*Bad Smell*
[source, java]
----
InputStream inputStream = null;
try {
    inputStream = new FileInputStream("NotDoThis.txt");
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (inputStream != null) {
        try {
            inputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
----
.*You Should Do Like That*
[source, java]
----
try (InputStream inputStream = new FileInputStream("Good.txt")) {
    // ...
} catch (IOException e) {
    e.printStackTrace();
}
----
NOTE: The Java version must be jdk1.7 or higher.

== Chapter 2: Methods Common to All Objects
When and how to override the nonfinal Object methods?

=== Item 10: Overriding equals general contract
.Not need to override equals method:
. Each instance of the class is inherently unique.
. There is no need for the class to provide a "logical equality" test.
. A supercalss has already overridden equals, and the superclass behavior is appropriate for this class.
. The class is private or package-private, and you are certain that its equlas method will never be invoked.

.General contract
. Reflexive: x != null, x.equals(x) must return true.
. Symmetric: x,y != null, x.equals(y) == y.equals(x).
. Transitive: x,y,z != null, x.equals(y) == y.equals(z) == z.equals(x)
. Consistent: x,y != null and x,y not modified, multiple invocation of x.equals(y) must consistently.
. x != null, x.equals(null) must return false.

[NOTE]
====
. Always override hashCode when you override equals.
. Don't try to be too clever.
. Don't substitude another type for Object in the equals declaration.

    public boolean equals(MyClass o) {
        // Don't do it like this!
    }
====

=== Item 11: Always override hashCode when you override equals
[source, java]
----
@Override
public int hashCode() {
    return Objects.hash(value1, value2, value3, ...);
}
----

=== Item 12: Always override toString

=== Item 13: Override clone judiciously

=== Item 14: Consider implementing Comparable

== Chapter 3: Classes and Interfaces
Help you make the best use of these powerful elements so that your classes and interfaces are usable, robust and flexible.

=== Item 15: Minimize the accessibility of classes and members
Make each class or member as inaccessible as possible.

If a package-private top-level class or interface is used by only one class, consider making the top-level class a private static nested class of sole class that use it.

If a method override a superclass method, it cannot have a more restrictive access level in the subclass than in the superclass.

Instance fields of public classes should rarely be public. Classes with public mutable fields are not generally thread-safe. The same advice applies to static fields, except you can expose constants via public static final fields.

Nonzero-legnth array is always mutable, so it is wrong for a class to have a public static final array fields, or an accessor that returns such a field.

=== Item 16: In public classes, use accessor methods, not public fields
If a class is accessible outside its package, provide accessor methods to preserve the flexibility to change the class's internal representation.

In summary, public classes should never expose mutable fields.

=== Item 17: Minimize mutability
An imutable class is simply a class whose instances cannot be modified. All of the information contained in each instance is fixed for the lifetime of the object, so no changes can ever be observed.

To make a class immutable, follow these five rules:
. Don't provide methods that modify the object's state.
. Ensure that the class can't be extended.
. Make all fields final.
. Make all fields private.
. Ensure exclusive access to any mutable components.
[source, java]
----
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double re() {
        return re;
    }

    public double im() {
        return im;
    }

    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }

    public Complex times(Complex c) {
        return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
    }

    public Complex dividedBy(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp);
    }
}
----
Immutable objects are simple. An immutable object can be in exactly one state, the state in which it was created.

Immutable objects are inherently thread-safe; they require no synchronization.

The major disadvantage of immutable classes is that they require a separate object for each distinct value.

Resist the urge to write a setter for every getter. Classes should be immutable unless there's a very good reason to make them mutable.

There are some classes for which immutability is impractical. If a class cannot be made immutable, limit its mutability as much as possible. Make every field final unless there is a compelling reason to make it nonfinal.

Construtors should create fully initialized objects with all of their invariants established. Don't provide a public initialization method separate from the constructor or static factory unless there is a compelling reason to do so.

=== Item 18: Favor composition over inheritance
Inheritance violates encapsulation. It is appropriate only when a genuine subtype relationship exists between the subclass and the superclass. Even then, inheritance may lead to fragility if the subclass is in a different package from the superclass and the superclass is not designed for inheritance.

== Item 19: Design and document for inheritance or else prohibit it
Test a class desiged for inheritance is to write subclasses. If you omit a crucial protected member, trying to write a subclass will make the omission painfully obvious.

If serveral subclasses are written and none uses a protected member, you should probably make it private.

Constructors must not invoke overridable methods.

The `Cloneable` and `Serializable` interfaces present special difficulties when designing for inheritance. Neither `clone` nor `readObject` may invoke an overridable method, directly or indirectly.