= Effective Java
:toc: left
:icons: font
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
Curry Cooky <currycooky@qq.com>
1.0, 2022-09-01

== Chapter 1: Creating and Destroying Objects
1. When and how to create objects?
2. When and how to avoid creating objects?
3. How to ensure objects are destroyed in a timely manner?
4. How to manage any cleanup actions that must precede their destruction?

=== Item 1: Use static factory methods
Like this:
[source, java]
----
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
----
The static factory method is not the same sa the _Factory Design Patterns_.

.*Advantages*
1. A static facotry method with a well-chosen name is easier to use and read.
2. Not required to create a new object each time they're invoked. Static factory method can cache object, and to avoid creating unnecessary duplicate objects, each time invoked always return same object.
3. Can return an object of any subtype of their return type, and return objects whithout making their classes public, like _SingletonSetfootnote:[java.util.Collections#singleton; java.util.Collections.SingletonSet]_.
4. Returned object can vary from call to call as a function of the input parameters, like _EnumSetfootnote:[java.util.EnumSet#noneOf]_.
5. Class of the returned object need not exist when the class containing the method is written, like _JDBC Driver_.

.*Disadvantages*
1. Is that classes without public or protected constructors cannot be subclassed. But this encourages programmers to use composition instead of inheritance.
2. Hard for programmers to find(I don't think this is a disadvantage.).

TIP: So, often static facoties are preferable, so we should first consider static factories.

=== Item 2: Consider using Builder instead of constructor with many parameters
.*Create Person Class*
[source, java]
----
public class Person {
    private final String id;
    private final String name;
    private final String sex;
    private final int age;

    public static class Builder {
        private final String id;
        private String name;
        private String sex;
        private int age;

        public Builder(String id) {
            this.id = id;
        }

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder man() {
            this.sex = "Man";
            return this;
        }

        public Builder woman() {
            this.sex = "Woman";
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Person build() {
            return new Person(this);
        }
    }

    private Person(Builder builder) {
        this.name = builder.name;
        this.id = builder.id;
        this.sex = builder.sex;
        this.age = builder.age;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getSex() {
        return sex;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", Person.class.getSimpleName() + "[", "]")
                .add("id='" + id + "'")
                .add("name='" + name + "'")
                .add("sex='" + sex + "'")
                .add("age=" + age)
                .toString();
    }
}
----

.*New Person Object*
[source, java]
----
Person person = new Person.Builder("423123412412313")
    .name("Zhang San")
    .age(20)
    .man()
    .build();
System.out.println(person.toString());
----

In real work, I like to use _Builder_ pattern very much. The pattern makes creating objects very elegant and easier to read. I heartily recommend this pattern to you.

TIP: In real work, we can use Lombokfootnote:[https://projectlombok.org/] to simplify code, just need to import Lombok, and use @Builder annotation, lombok can generate Builder class by auto.

=== Item 3: Implementing Singleton with a private constructor or an Enum type
.*private constructor*
[source, java]
----
public class Person {
    private static final Person INSTANCE = new Person();

    private Person() {}

    public static Person getInstatnce() {
        return INSTANCE;
    }

    public void eating() {
        System.out.println("I'm eating.");
    }
}
----

.*Enum type*
[source, java]
----
public enum Person {
    INSTANCE;

    public void eating() {
        System.out.println("I'm eating.");
    }
}
----
TIP: Recommend using Enum type.

=== Item 4: Enforce noninstantiablity with a private constructor
[source, java]
----
public class UtilityClass {
    private UtilityClass() {
        throw new SomeError();
    }

    public static boolean negation(boolean flag) {
        return !flag;
    }
}
----
We also can add `final` flag to this class make it cannot be extend.
[source, java]
----
public final class UtilityClass {
    private UtilityClass() {
        throw new SomeError();
    }

    public static boolean negation(boolean flag) {
        return !flag;
    }
}
----

=== Item 5: Prefer dependency injection to hardwiring resources
.*Noncompliant Code Example*
[source, java]
----
public class A {
    public void exe() {
        B b = new B();
        b.exe();
    }
}
----

.*Compliant Code Example*
[source, java]
----
public class A {
    private final B b;

    public A(B b) {
        this.b = b;
    }

    public void exe() {
        b.exe();
    }
}
----

=== Item 6: Avoid creating unnecessary objects
Example:
[source, java]
----
public boolean isRoman(String s) {
    return s.matches("ROMAN");
}
----
We can see `matches()` source code, each time invoke, `matches()` will create a Pattern instance, and uses it only once and then destroy it.

We could totally create an immutable Pattern instance, cache it, and can give it an appropriate name.
[source, java]
----
private static final Pattern ROMAN = Pattern.compile("ROMAN");

public boolean isRoman(String s) {
    return ROMAN.matcher(s).matches();
}
----
And avoid to create unnecessary objects is autoboxing.

=== Item 7: Eliminate obsolete object references
Memory leaks in garbage-collected languages are insidious. If an object reference is unintentionally retained, not only is that object excluded from garbage coolection, but so too are any objects referenced by that object, and so on.

Generally speaking, whenever a class manages its own memory, the programer should be alter for memory leaks. Whenever an element is freed, any object references contained in the element should be nulled out.

=== Item 8: Avoid finalizers and cleaners
IMPORTANT: NEVER! USE! THE! FINALIZER! METHOD!

=== Item 9: Prefer try-with-resources to try-finally
.*Bad Smell*
[source, java]
----
InputStream inputStream = null;
try {
    inputStream = new FileInputStream("NotDoThis.txt");
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (inputStream != null) {
        try {
            inputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
----
.*You Should Do Like That*
[source, java]
----
try (InputStream inputStream = new FileInputStream("Good.txt")) {
    // ...
} catch (IOException e) {
    e.printStackTrace();
}
----
NOTE: The Java version must be jdk1.7 or higher.

== Chapter 2: Methods Common to All Objects
When and how to override the nonfinal Object methods?

=== Item 10: Overriding equals general contract
.Not need to override equals method:
. Each instance of the class is inherently unique.
. There is no need for the class to provide a "logical equality" test.
. A supercalss has already overridden equals, and the superclass behavior is appropriate for this class.
. The class is private or package-private, and you are certain that its equlas method will never be invoked.

.General contract
. Reflexive: x != null, x.equals(x) must return true.
. Symmetric: x,y != null, x.equals(y) == y.equals(x).
. Transitive: x,y,z != null, x.equals(y) == y.equals(z) == z.equals(x)
. Consistent: x,y != null and x,y not modified, multiple invocation of x.equals(y) must consistently.
. x != null, x.equals(null) must return false.

[NOTE]
====
. Always override hashCode when you override equals.
. Don't try to be too clever.
. Don't substitude another type for Object in the equals declaration.

    public boolean equals(MyClass o) {
        // Don't do it like this!
    }
====

=== Item 11: Always override hashCode when you override equals
[source, java]
----
@Override
public int hashCode() {
    return Objects.hash(value1, value2, value3, ...);
}
----

=== Item 12: Always override toString

=== Item 13: Override clone judiciously

=== Item 14: Consider implementing Comparable

== Chapter 3: Classes and Interfaces
Help you make the best use of these powerful elements so that your classes and interfaces are usable, robust and flexible.

=== Item 15: Minimize the accessibility of classes and members
Make each class or member as inaccessible as possible.

If a package-private top-level class or interface is used by only one class, consider making the top-level class a private static nested class of sole class that use it.

If a method override a superclass method, it cannot have a more restrictive access level in the subclass than in the superclass.

Instance fields of public classes should rarely be public. Classes with public mutable fields are not generally thread-safe. The same advice applies to static fields, except you can expose constants via public static final fields.

Nonzero-legnth array is always mutable, so it is wrong for a class to have a public static final array fields, or an accessor that returns such a field.

=== Item 16: In public classes, use accessor methods, not public fields
If a class is accessible outside its package, provide accessor methods to preserve the flexibility to change the class's internal representation.

In summary, public classes should never expose mutable fields.

=== Item 17: Minimize mutability
An imutable class is simply a class whose instances cannot be modified. All of the information contained in each instance is fixed for the lifetime of the object, so no changes can ever be observed.

To make a class immutable, follow these five rules:
. Don't provide methods that modify the object's state.
. Ensure that the class can't be extended.
. Make all fields final.
. Make all fields private.
. Ensure exclusive access to any mutable components.
[source, java]
----
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public double re() {
        return re;
    }

    public double im() {
        return im;
    }

    public Complex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }

    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }

    public Complex times(Complex c) {
        return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
    }

    public Complex dividedBy(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp);
    }
}
----
Immutable objects are simple. An immutable object can be in exactly one state, the state in which it was created.

Immutable objects are inherently thread-safe; they require no synchronization.

The major disadvantage of immutable classes is that they require a separate object for each distinct value.

Resist the urge to write a setter for every getter. Classes should be immutable unless there's a very good reason to make them mutable.

There are some classes for which immutability is impractical. If a class cannot be made immutable, limit its mutability as much as possible. Make every field final unless there is a compelling reason to make it nonfinal.

Construtors should create fully initialized objects with all of their invariants established. Don't provide a public initialization method separate from the constructor or static factory unless there is a compelling reason to do so.

=== Item 18: Favor composition over inheritance
Inheritance violates encapsulation. It is appropriate only when a genuine subtype relationship exists between the subclass and the superclass. Even then, inheritance may lead to fragility if the subclass is in a different package from the superclass and the superclass is not designed for inheritance.

=== Item 19: Design and document for inheritance or else prohibit it
Test a class desiged for inheritance is to write subclasses. If you omit a crucial protected member, trying to write a subclass will make the omission painfully obvious.

If serveral subclasses are written and none uses a protected member, you should probably make it private.

Constructors must not invoke overridable methods.

The `Cloneable` and `Serializable` interfaces present special difficulties when designing for inheritance. Neither `clone` nor `readObject` may invoke an overridable method, directly or indirectly.

If you decide to implement `Serializable` in a class designed for inheritance and the class has a `readResolve` or `writeReplace` method, you must make them protected rather than private.

Designing a class for inheritance requires great effort and places substantial limitations on the class.

=== Item 20: Prefer interfaces to abstract classes
Existing classes cannot, in general, be retrofitted to extend a new abstract class. If you want to have two classes extend the same abstract class, you have to place it high up in the type hierarchy where it is an ancestor of both classes. Unfortunately, this can cause great collateral damage to the type hierarchy, forcing all descendants of the new abstract class to subclass it, whether or not it is appropriate.

=== Item 21: Design interfaces for posterity
Utmost importace to design interfaces with great care.

Test each new interface before you release it.

=== Item 22: Use interfaces only to define types
Do not use constant interface! The constant interface pattern is a poor use of interfaces. That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementtation detail to leak into the class's exported API.
[source, java]
----
public interface PhysicalConstatns {
    static final double NUMBER = 2.0D;
}
----

=== Item 23: Prefer class hierarchies to tagged classes
Tagged classes have numerous shortcomings. They are cluttered with bolierplate, including enum declasrations, tag fields, and switch statements. Readability and flexibility is further harmed because multiple implementations are jumbled together in a single class, and memory footprint is increased. Tagged classes are verbose, error-prone, and inefficient.
[source, java]
----
public abstract class Figure {
    abstract double area();
}

public class Circle extends Figure {
    final double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double area() {
        return Math.PI * (radius * radius);
    }
}

public class Rectangle extends Figure {
    final double length;
    final double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    double area() {
        return length * width;
    }
}
----

=== Item 24: Favor static member classes over nonstatic
If you declare a member class that does not require access to an eclosing instance, always put the static modifier in its declaration, making it s static rather than a nonstatic member class.

=== Item 25: Limit source files to a single top-level class
Never put multiple top-level classes or interfaces in a single source file.
[source, java]
----
public class Circle extends Figure {
    final double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double area() {
        return Math.PI * (radius * radius);
    }
}

public class Rectangle extends Figure {
    final double length;
    final double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    double area() {
        return length * width;
    }
}
----
[source, java]
----
public abstract class Figure {
    abstract double area();

    public class Circle extends Figure {
        final double radius;

        public Circle(double radius) {
            this.radius = radius;
        }

        @Override
        double area() {
            return Math.PI * (radius * radius);
        }
    }

    public class Rectangle extends Figure {
        final double length;
        final double width;

        public Rectangle(double length, double width) {
            this.length = length;
            this.width = width;
        }

        @Override
        double area() {
            return length * width;
        }
    }

}
----

== Chapter 4: Generics
How to maximize the benefits and minimize the complications.

=== Item 26: Don't use raw types
[source, java]
----
// Don't do this!
private final Collection stamps = ...;
----
If you use raw types, you lose all safety and expressiveness benefits of Generics, but not if you use a parameterized type such as List<Objecjt>.

=== Item 27: Eliminate unchecked warnings
[source, java]
----
// Don't do this!
Set<String> strs = new HashSet();

// You can do like this.
Set<String> strs = new HashSet<>();
----
Eliminate every unchecked warning that you can. If you eliminate all warnings, you are assured that you code is typesafe, which is a very good thing.

If you cann't eliminate a warning, but you can prove that the code that provoked the warning is typesafe, then (and only then) suppress the warning with an `@SuppressWarnings("unchecked")` annotation. Always use the `@SuppressWarnings` on the smallest scope possible, never use it on an entire class.

Also can declare a local variable:
[source, java]
----
@SuppressWarnings("unchecked") T[] result = Arryas.copyOf(elements, size, a.getClass());
----

Every time you use a `@SuppressWanings("unchecked")` annotation, add a comment saying why it is safe to do so.

=== Item 28: Prefer lists to arrays
[source, java]
----
Object[] objs = new Long[1];
objs[0] = "Error"; // Throws ArrayStoreException
----

[source, java]
----
List<Object> objs = new ArrayList<Long>(); // Incompatible types, won't compile!
----

=== Item 29: Favor generic types
Generic types are safer and easier to use than types that require casts in client code.
[source, java]
----
public class Stack<E> {
    private E[] elemetns;

    public Stack() {
        elements = (E[]) new Object[16];
    }
}
----

=== Item 30: Favor generic methods
[source, java]
----
// Uses raw types - unacceptable!
public static Set union(Set s1, Set s2) {
    Set res = new HashSet(s1);
    res.addAll(s2);
    return res;
}
----
[source, java]
----
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    Set<E> res = new HashSet<>(s1);
    res.addAll(s2);
    return res;
}
----

=== Item 31: Use bounded wildcards to increate API flexibility
[source, java]
----
public void pushAll(Iterable<? extends E> src) {
    for (E e : src) {
        push(e);
    }
}
----
For maximum flexibility, use wildcard types on input parameters that represent producers or consumers. If an input parameter is both a producer and a consumer, then wildcard types will do you no good: you need an exact  type match, which is what you get without any wildcards.

[.text-center]
*PECS stands for producer-extends, consumer-super*

Do not use bounded wildcard types as return types. If the user of a  class has to think about wildcard types, there is probably something wrong with its API.

=== Item 32: Combine generics and varargs judiciously
Recall that a generic array is created when the method is invoked, to hold the varargs parameters. If the method doesn't store anything into the array (which would overwrite the parameters) and doesn't allow a reference to the array to escape (which would enable untrusted code to access the array), then it's safe.

In summary, varargs and generics do not interact well because the varargs facility is a leaky abstraction built atop arrays, and arrays have different type rules from generics. Though generic varargs parameters are not typesafe, they are legal. If you choose to write a method with a generic (or parameterized) varargs parameter, first ensure that the method is typesafe, and then annotate it with `@SafeVarargs` so it is not unpleasant to use.

=== Item 33: Consider typesafe heterogeneous containers
[source, java]
----
public class Favorites {
    private Map<Class<?>, Object> favorites = new HashMap<>();

    public <T> void putFavorite(Class<T> type, T instance) {
        favorites.put(Objects.requireNonNull(type), type.cast(instance));
    }

    public <T> T getFavorite(Class<T> type) {
        return type.cast(favorites.get(type));
    }
}
----
The normal use of generics, exemplified by the collections APIS, restricts you to a fixed number of type parameters per container. You can get around this restriction by placing the type parameter on the key rather than the container.

== Chapter 5: Enums and Annotations

=== Item 34: Use enums instead of int constants
[source, java]
----
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;
public static final int ORANGE_NAVEL = 0;
----
This technique, known as the `_int enum pattern_`, has many shortcomings. It provides nothing in the way of type safety and little in the way of expressive power. The compiler won't complain if you pass an apple to a method that expects an orange, compare apples to orange with the `==` operator, or worse.

If you print such a constant or display it from a debugger, all you see is a number, which isn't very helpful.

Enums provide compile-time type safety. Attempts to pass values of the wrong type will result in compile-time errors, as will attempts to assign an expression of one enum type to a variable of another, or to use the `==` operator to compare values of different enum types.

Enum types with identically named constants coexist peachfully. You can add or reorder constants in an enum type without recompliling its clients. Finally, you can translate enums into printable strings by calling their `toString` method.

Enum types let you add arbitrary methods and fields and implement arbitrary interfaces.
[source, java]
----
public enum Operation {
    PLUS {
        public double apply(double x, double y) {
            return x + y;
        }
    },

    MINUS {
        public double apply(double x, double y) {
            return x - y;
        }
    }
}
----

So when should you use enums? Use enums any time you need a set of constants whose members are known at compile time.

=== Item 35: Use instance fields instead of ordinals
All enums have an `ordinal` method, which returns the numberical position of each enum constant in its type. But you should never use it.
[source, java]
----
public enum NumberEnum {
    ONE, TWO, THREE;

    public int num() {
        return ordinal();
    }
}
----
If the constants are reordered, the `num` method will break.

Never derive a value associated with an enum from its ordinal; store it in an instance field instead.
[source, java]
----
public enum NumberEnum {
    ONE(1), TWO(2), THREE(3);

    private final int num;

    NumberEnum(int num) {
        this.num = num;
    }

    public int num() {
        return num;
    }
}
----

=== Item 36: Use EnumSet instead of bit fields
[source, java]
----
public class Text {
    public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }
         
    // Any Set could be passed in, but EnumSet is clearly best
    public void applyStyles(Set<Style> styles) {
        // ...
    }
}

text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));
----

=== Item 37: Use EnumMap instead of ordinal indexing

=== Item 38: Emulate extensible enums with interfaces
[source, java]
----
public interface EnumInterface {
    int apply(int a);
}
----
[source, java]
----
public enum InterfaceEnum implements EnumInterface {
    A {
        @Override
        public int apply(int a) {
            return a + 'a';
        }
    },
    B {
        @Override
        public int apply(int a) {
            return a + 'b';
        }
    }
}
----

[source, java]
----
public <T extends Enum<T> & EnumInterface> void test(Class<T> enums, int a) {
    for (T t : enums.getEnumConstants()) {
        System.out.println(t.apply(a));
    }
}
----

=== Item 39: Prefer annotaions to naming patterns
Naming patterns has serveral big disadvantages. First, typographical errors result in silent failures. Second, naming patterns is no way to ensure that they are used only on approprite program elements. And third, they provide no good way to associate parameter values with program elements.

=== Item 40: Consistently use the Override annotaion
If you consistently use this annotation, it will protect you from a large nefarious bugs. Use the `@Override` on every method declaration that you believe to override a superclass declaration.

=== Item 41: Use marker interfaces to define types
A _marker interface_ is an interface that contains no method declarations but merely designates (or "marks") a class that implements the interface as having some property (`Serializable`).

Marker interfaces have two advantages over marker annotations. First and foremost, marker interfaces define a type that is implemented by instances of the marked class; marker annotations do not. Another advantage of marker interfaces over marker annotations is that they can be targeted more precisely.

If the marker applies to any program element other that a class or interface, you must use an annotation. If the marker applies only to classes and interfaces, ask yourself the question "Might I want to write one or more methods that accept only objects that have this marking?" If so, you should use a marker interface in preference to an annotation.

== Chapter 6: Lambdas and Streams
How to make best use of lambdas and streams.

=== Item 42: Prefer lambdas to anonymous classes
[source, java]
----
// Anonymous class
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});

// Lambda
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
----

Lambdas lack names and documentation; if a computation isn't self-explanatory, or exceeds a few lines, don't put it in a lambda.

One line is ideal for a lammbda, and three lines is a reasonable maximum.

Lambdas share with anonymous classes the property that you can't reliably serialize and deserialize them across implementations. Therefore, you should rarely, if ever, serialize a lambda.

If you have a function object that you want to make serializable, use an instance of a priavte static nested class.

Don't use anonymous classes for function objects unless you have to create instances of types that aren't functional interafces.

=== Item 43: Prefer method references to lambdas
[source, java]
----
// lambda
map.merge(key, 1, (count, incr) -> count + incr);

// method
map.merge(key, 1, Integer::sum);
----

You should usually, but not always, replace a lambda with a method reference. Occasionally, a lambda will be more succinct than a method reference.
[source, java]
----
// method
service.execute(GoshThisClassNameIsHumongous::action);

// lambda
service.execute(() -> action());
----

Where method references are shorter and clearer, use them; where they aren't, stick with lambdas.

=== Item 44: Favor the use of standard functional interfaces

[cols="1,1"]
|===
|Interface |Function Signature

|UnaryOperator<T>
|T apply(T t)

|BinaryOperator<T>
|T apply(T t1, T t2)

|Predicate<T>
|boolean test(T t)

|Function<T,R>
|R apply(T t)

|Supplier<T>
|T get()

|Consumer<T>
|void accept(T t)
|===

Don't be tempted to use basic functional interfaces with boxed primitives instead of primitive functional interfaces.

Notice that the interface is labeled with the `@FunctionalInterface` annotation.

Do not provide a method with multiple overloadings that take different functional interfaces in the same argument position if it could create a possible ambiguity in the client.

=== Item 45: Use streams judiciously
The streams API is sufficiently versatile that practically any computation can be performed using streams, but just because you can doesn't mean you should. When used appropriately, streams can make programs shorter and clearer; when used inappropriately, they can make programs difficult to read and maintain.

Overusing streams makes programs hard to read and maintain.

In the absence of explicit types, careful naming of lambda parameters is essential to the readability of stream pipelines.

Using helper methods is even more important for readability in stream pipelines that in iterative code.

If you're not sure whether a task is better served by streams or iteration, try both and see which works better.

=== Item 46: Prefer side-effect-free funcitons in streams
Do anything more than present the result of the computation performed by a stream is a "bad smell in code", as is a lambda that mutates state.

The forEach operation should be used only to report the result of a stream computation, not to perform the computation.

It is customary and wise to statically import all members of Collectors because it makes stream pipelines more readable.

=== Item 47: Prefer Collection to Stream as a return type
The `Collection` interface is a subtype of `Iterable` and has a `stream` method, so it provides for both iteration and stream access. Therefore, Collection or an appropriate subtype is generally the best return type for a public, sequence-returning method.

=== Item 48: Use caution when making streams parallel
Even under the best of circumstances, parallelizing a pipeline is unlikely to increase its performance if the source is from Stream.iterate, or the intermediate operation limit is used.

Do not parallelize stream pipelines indiscriminately. The performance consequences may be disastrous.

Performance gains from parallelism are best on streams over ArryayList, HashMap, HashSet, and ConcurrentHashMap instances; arrays; int ranges; and long ranges.

Not only can parallelizing a stream lead t poor performance, including liveness failures; it can lead to incorrect results and unpredictable behavior.

In summary, do not even attempt to parallelize a stream pipeline unless you have good reason to believe that it will preserve the correctness of the computation and increase its speed.

== Chapter 7: Methods
How to treat parameters and return values, how to design method signatures, and how to document methods. This chapter focuses on usability, robustness, and flexibility.

=== Item 49: Check parameters for validity
Each time you write a method or constructor, you should think about what restrictions exist on its parameters. You should document these restrictions and enforce them with explicit checks at the beginning of the method body.

=== Item 50: Make defensive copies when needed
[source, java]
----
Date start = new Date(), end = new Date();
Period p = new Period(start, end);
end.setYear(78); // modifies internals of p
----

If a class has mutable components that it gets from or returns to its clients, the class must defensively copy these components.

If the cost of the copy whould be prohibitive and the class trusts its clients not to modify the components inappropriately, then the defensive copy may be replaced by documentation outlining the client's responsibility not to modify the affected components.

=== Item 51: Design method signatures carefully
Choose method names carefully. Names should always obey the standard naming conventions. Choose names that are understandable and consistent with other names in the same package. Avoid long method names.

Do't go overboard in providing convenience methods. Too many methods make a class difficult to learn, use, document, test, and maintain.

Avoid long parameter lists.

For parameter types, facor interfaces over classes.

Prefer two-element enum types to boolean parameters, unless the meaning of the boolean is clear from the method name.

=== Item 52: Use overloading judiciously
It is generally best to refrain from overloading methods with multiple signatures that have the same number of parameters.

=== Item 53: Use varargs judiciously
Varargs are invaluable when you need to define methods with a variable number of arguments. Precede the varargs parameter with any required parameters, and be aware of the performance consequences of using varargs.

=== Item 54: Return empty collections or arrays, not nulls
Never return null in place of an empty array or collection. It makes your API more difficult to use and more prone to error, and it has no performance advantages.

=== Item 55: Return optionals judiciously
You should be aware that there are real performance consequences associated with returning optionals; for performance-critical methods, it may be better to return a null or throw an exception.

=== Item 56: Write doc comments for all exposed API elements
Documentation comments are the best, most effective way to document your API. Their use should be considered mandatory for all exported API elements.

== Chapter 8: General Programming

=== Item 57: Minimize the scope of local variables
The most powerful technique for minimizing the scope of a local variable is to declare it where it is first used.

Nearly every local variable declaration should contain an initializer.

[source, java]
----
Iterator<String> i1 = l1.iterator();
while (i1.hasNext()) {
    doSomething(i1.next());
}

Iterator<String> i2 = l2.iterator();
while (i1.hasNext()) {
    doSomething(i2.next()); // BUG!!!
}
----

[source, java]
----
for (Iterator<String> i1 = l1.iterator(); i1.hasNext(); ) {
    doSomething(i1.next());
}

for (Iterator<String> i2 = l2.iterator(); i2.hasNext(); ) {
    // cannot find symbol i1
    doSomething(i2.next());
}
----

A final technique to minimize the scope of local variables is to keep methods small and focused.

=== Item 58: Prefer for-each loops to traditional for loops
For-each loop provides compelling advantages over the traditional for loop in clarity, flexibility, and bug prevention, with no performance penalty.

=== Item 59: Know and use the libraries
By using a standard library, you take advantage of the knowledge of the experts who wrote it and the experience of those who use id before you.

____
We should n longer use `Random`. For most users, the random number generator of choice is now `ThreadLocalRandom`. For fork join pools and parallel streams, use `SplittableRandom`.
____

Every programmer should be familiar with the basics of `java.lang`, `java.util`, and `java.io`, and their subpackages. Knowledge of other libraries can be acquired on an as-needed basis.

If you can't find what you need in Java platform libraries, your next choice should be to look in high-quality third-party libraries, such as Google's excellent, open source Guava library. If you can't find the functionality that you need in any appropriate library, you may have no choice but to implement it yourself.

NOTE: Don't reinvent the wheel.

=== Item 60: Avoid float and double if exact answers are required
The float and double types are particularly ill-suited for monetary calculations because it is impossible to represent 0.1 (or any other negative power of ten) as a float or double exactly.

The right way is to use BigDecimal, int, or long for monetary calculations.