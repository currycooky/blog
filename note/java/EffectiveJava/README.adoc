= Effective Java
:toc: left
:icons: font
Curry Cooky <currycooky@qq.com>
1.0, 2022-09-01

== Chapter 1
1. When and how to create objects?
2. When and how to avoid creating objects?
3. How to ensure objects are destroyed in a timely manner?
4. How to manage any cleanup actions that must precede their destruction?

=== Item 1: Use static factory methods
Like this:
[source, java]
----
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
----
The static factory method is not the same sa the _Factory Design Patterns_.

.*Advantages*
1. A static facotry method with a well-chosen name is easier to use and read.
2. Not required to create a new object each time they're invoked. Static factory method can cache object, and to avoid creating unnecessary duplicate objects, each time invoked always return same object.
3. Can return an object of any subtype of their return type, and return objects whithout making their classes public, like _SingletonSetfootnote:[java.util.Collections#singleton; java.util.Collections.SingletonSet]_.
4. Returned object can vary from call to call as a function of the input parameters, like _EnumSetfootnote:[java.util.EnumSet#noneOf]_.
5. Class of the returned object need not exist when the class containing the method is written, like _JDBC Driver_.

.*Disadvantages*
1. Is that classes without public or protected constructors cannot be subclassed. But this encourages programmers to use composition instead of inheritance.
2. Hard for programmers to find(I don't think this is a disadvantage.).


TIP: So, often static facoties are preferable, so we should first consider static factories.

=== Item 2: Consider using Builder instead of constructor with many parameters
.*Create Person Class*
[source, java]
----
public class Person {
    private final String id;
    private final String name;
    private final String sex;
    private final int age;

    public static class Builder {
        private final String id;
        private String name;
        private String sex;
        private int age;

        public Builder(String id) {
            this.id = id;
        }

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder man() {
            this.sex = "Man";
            return this;
        }

        public Builder woman() {
            this.sex = "Woman";
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Person build() {
            return new Person(this);
        }
    }

    private Person(Builder builder) {
        this.name = builder.name;
        this.id = builder.id;
        this.sex = builder.sex;
        this.age = builder.age;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getSex() {
        return sex;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", Person.class.getSimpleName() + "[", "]")
                .add("id='" + id + "'")
                .add("name='" + name + "'")
                .add("sex='" + sex + "'")
                .add("age=" + age)
                .toString();
    }
}
----

.*New Person Object*
[source, java]
----
Person person = new Person.Builder("423123412412313")
    .name("Zhang San")
    .age(20)
    .man()
    .build();
System.out.println(person.toString());
----

In real work, I like to use _Builder_ pattern very much. The pattern makes creating objects very elegant and easier to read. I heartily recommend this pattern to you.

TIP: In real work, we can use Lombokfootnote:[https://projectlombok.org/] to simplify code, just need to import Lombok, and use @Builder annotation, lombok can generate Builder class by auto.