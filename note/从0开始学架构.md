# 从0开始学架构

## 高性能NoSQL

### 关系型数据库存在的一些缺点：

* 关系数据库存储的是行，而不是数据结构，这意味着我们无法直接存储成我们需要的数据结构，只能从数据库中按列查询出来，然后再手动封装成我们需要的结构。
* schema扩展不方便，是强约束，如果操作的列不存在就会报错，而且在面对扩充列时会非常麻烦，如果数据量太大，修改时锁表的时间会非常长。
* 关系数据库在大数据场景下I/O较高，比如一些统计之类的运算，就算只针对其中的某一列，但关系数据库依旧会查询出整行数据读入内存。
* 关系数据库全文搜索功能比较弱，比如like操作，关系数据库会进行整表扫描匹配，性能非常低。

### 常见的NoSQL方案：

* K-V存储：解决无法存储数据结构的问题，以Redis为代表
* 文档数据库：解决schema强约束的问题，以MongoDB为代表。
* 列式数据库：解决大数据场景下的I/O问题，以HBase为代表。
* 全文搜索引擎：解决全文搜索的性能问题，以Elasticsearch为代表。

### 根据不同的需求，确立选择不同的数据库：

* 管理型系统，如运营类系统，首选关系型。
* 大流量系统，如电商单品页的某个服务，后台选关系型，前台选内存型。
* 日志型系统，原始数据选列式，日志搜索选倒排索引。
* 搜索型系统，指站内搜索，非通用搜索，如商品搜索，后台选关系型，前台选倒排索引。
* 事务型系统，如库存、交易、记账，选关系型+缓存+一致性协议，或新型关系数据库。
* 离线计算，如大量数据分析，首选列式，关系型也可以。
* 实时计算，如实时监控，可以选时序数据库，或列式数据库。

## 高性能缓存架构

### 缓存穿透

缓存穿透是指缓存没有发生作用，业务系统虽然去缓存查数据，但缓存中没有数据，业务系统需要再次去查询数据库。

具体有以下几种情况：

1. 存储数据不存在

   这种情况，在发现数据确实不存在之后，可以在缓存中设置一个默认值，也可以是空值，这样下一次请求就会直接返回缓存中的结果，不会去查数据库，但是同时要注意缓存的有效性，避免数据库已经有值了，但缓存依然返回空。

2. 缓存数据生成耗费大量时间或资源

   比较典型的是电商的商品分页，因为商品的数据量很大，不可能全部缓存，所以一般可能会按照分页来进行缓存。但是由于很难预测用户会访问哪些分页，所以一般是每次点击分页的时候就按分页计算缓存数据。但是如果遇到了爬虫遍历，就可能导致系统性能出现问题。

   这种情况也没有比较好的方案，最好的就是做好监控，一旦发现问题就及时处理。

### 缓存雪崩

缓存雪崩是指缓存失效后，系统需要重新去查数据库然后生成缓存，但是如果是高并发下，这一瞬间可能已经有了很多请求进来，他们都不知道已经有其他线程在生成缓存数据了，所以会全部去查询数据库，从而造成巨大的性能压力。这些压力又会拖慢整个系统，从而导致连锁反应，造成整个系统崩溃。

常见的解决方式有两种：更新锁机制和后台更新机制。

1. 更新锁

   对缓存更新操作进行加锁保护，保证只有一个线程能进行缓存更新，未能获得更新锁的要么等待锁释放后重新读取缓存，要么直接返回默认值。

   对于分布式集群，要采用分布式锁，确保只有一个线程在更新缓存。

2. 后台更新

   缓存本身设置为永久，用一个后台线程，定时去更新缓存，而不是由业务线程去更新。

   同时要注意缓存内存空间不够时，删除了一些缓存数据。这种情况我们可以通过两种方式去解决：

   * 后台线程除了定时更新，还要定时查询，而且查询的时间间隔不能太长。
   * 业务线程发现缓存失效后，向后台线程发送一条消息通知，后台线程接收到通知后立即开始更新数据。

   后台更新还可以缓存预热。系统上线后，在用户请求前就将数据加载到缓存中。

### 缓存热点

对于热点数据，缓存这一份热点数据的服务器压力会很大。

**解决方案就是复制多份副本**。注意缓存的过期时间不能设置成一样的，而应该是在一个区间内随机，避免同时过期造成缓存雪崩。

## 单服务器高性能模式：PPC|TPC

### PPC

每次有新的连接，就新建一个进程去专门处理这个连接：

1. 父进程接受连接。
2. 父进程`fork`子进程。
3. 子进程处理连接的读写请求。
4. 子进程关闭连接。

这种方式比较简单，适合服务器连接数不多的情况。如果服务器的并发和访问量增加到上千万，这种模式的缺点就会暴露出来：

1. `fork`代价高，需要分配很多内核资源，即使使用`Copy on Write`技术，总体来说代价也是很大的。
2. 父子进程通信复杂，需要采用`IPC（Interprocess Communication）`之类的进程通信方案。
3. 支持的并发连接数量有限。

#### prefork

在系统启动的时候就预先创建好进程，然后才开始接受请求，当有新连接进来时，就可以省去`fork`进程的操作，从而提升用户的访问速度。

**实现关键**

多个子进程都`accpet`同一个`socket`，当有新的连接进入时，操作系统保证只有一个进程最后能`accpet`成功。

**“惊群”现象**

所有阻塞在`accpet`上的子进程都会被唤醒，会导致不必要的进程调度和上下文切换。

不过操作系统可以解决这个问题，比如Linux2.6版本后内核已经解决了“惊群”问题。

### TPC

每次有新的连接就新建一个线程去专门处理，比起进程，线程更加轻量，消耗更少。同时多线程是共享进程内存空间的，线程通信相比进程通信更加简单。

存在的一些问题：

* 虽然线程比进程代价低，高并发是还是会有性能问题。
* 线程间的互斥和共享引入了复杂度，可能会导致死锁的问题。
* 多线程会出现互相影响的情况，某个线程出现异常时，可能会导致整个进程退出。

TPC方案本质上和PPC方案基本类似，相反的，在并发几百的场景下，更多的还是使用PPC，因为其不会有死锁的风险，也不会多进程互相影响，更加稳定。

#### prethread

预先创建线程，然后才开始接受用户的请求。

## 单服务器高性能模式：Reactor与Proactor

### Reactor

I/O多路复用结合线程池。

* 当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，无须再轮询所有连接，常见的方式有select、epoll、kqueue等。
* 当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。

### Proactor

`Reactor`可以理解为：来了事情我通知你，你去处理；`Proactor`可以理解为：来了事件我来处理，我处理好了通知你。

## 高性能负载均衡

### 负载均衡分类

常见的包括三种：DNS、硬件和软件。

### 算法

* 轮询
* 加权轮询
* 负载最低优先
* 性能最优类
* Hash类

## CAP

一致性Consistency、可用性Availability、分区容忍性Partition Tolerance。

在一个分布式系统中，当涉及读写操作时，只能保证一致性、可用性、分区容忍性三者中的两个，另外一个必须被牺牲。

在分布式环境下，必须选择P要素，因为网络不是100%可靠，很有可能出故障，所以分区是一个必然的现象。理论上分布式系统不可能选择CA架构，只能选择CP或者AP架构。

**CP**

为了保证一致性，当发生分区情况时，我们会将持有旧数据的节点比较为不可用（比如提示系统发生了错误），这个时候已经破坏了A。

**AP**

为了保证可用性，当发生分区情况后，持有新数据的节点无法将新数据更新到旧数据节点中，这样虽然旧数据节点可以访问，但获取到的数据不是最新的，破坏了C。

## FMEA

Failure mode and effects analysis，故障模式与影响分析，又称为失效模式与后果分析、失效模式与效应分析、故障模式与后果分析等。

FMEA是一套分析和思考的方法，而不是某个领域的技能或者工具。

### FEMA方法

* 给出初始的架构设计图。
* 假设架构中某个部件发生故障。
* 分析此故障对系统功能造成的影响。
* 根据分析结果，判断架构是否需要进行优化。

1. 功能点

   功能点是从用户角度来看的，而不是从系统各个模块功能点划分。

2. 故障模式

   并不需要给出故障的原因，只需要分析出现的故障的现象。对于故障的描述要具体可量化，避免过于泛化。

3. 故障影响

   功能点偶尔不可用、功能点完全不可用、部分用户功能点不可用、功能点响应缓慢、功能点出错等。

   故障影响也应该尽量准确描述，可量化。

4. 严重程度

   一般分为：致命、高、中、低、无。

   严重程度 = 功能点重要程度 * 故障影响范围 * 功能点受损程度。

   当对严重程度的定义出现争议时，不必太花时间争论，由相关人员讨论确定即可，实在不行可以由架构师裁定。

5. 故障原因

   * 不同的故障原因发生概率不同。
   * 不同的故障原因检测手段不一样。
   * 不同的故障原因的处理措施不一样。

6. 故障概率

   一般分高中低三档即可，没必要绝对量化。

   * 硬件。
   * 开源系统。
   * 自研系统。

7. 风险程度

   风险程度 = 严重程度 * 故障概率。

8. 已有措施

   一般有检测告警、容错、自恢复等手段。

9. 规避措施

   可以是技术手段，也可以是管理手段。

10. 解决措施

    一般是技术手段。如果既可以通过规避措施解决，又可以通过解决措施解决，那么优先选择解决措施。

11. 后续规划

## 收集

### 面试问题

**数据库自身不是有缓存吗？为什么还要引入其他NoSQL缓存？**

1. MySQL有结果缓存，但条件苛刻，程序员不可控。
2. 更新此表的其他数据也会导致这个表的缓存失效，并不仅限于同一条数据，新版已经废弃了这个功能。
3. `innodb buffer pool`缓存的是数据，而不是结果，SQL的执行过程无法省略，而NoSQL缓存的则直接是结果，性能差距很远。

### 开源框架

**缓存框架：`https://github.com/qiujiayu/AutoLoadCache`**

1. 缓存操作与业务代码耦合问题。
2. 缓存穿透问题。
3. 异步刷新缓存。
4. 降低回源并发量。

### 文章

* [微信红包后台系统设计](https://cloud.tencent.com/developer/article/1637408)
* [百亿级微信红包的高并发资金交易系统设计方案](https://www.infoq.cn/article/2017hongbao-weixin)

### 推荐书籍

* 《高性能MySQL》
* 《UNIX编程艺术》
* 《UNIX 网络编程》